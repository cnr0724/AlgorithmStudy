1. 컴퓨터 알고리즘이란?
컴퓨터를 이용해 주어진 문제를 단계로 나누어 효율적으로 해결하기 위한 방법 혹은 절차.
컴퓨터 언어나 컴퓨터 프로그램과는 구분됨.

알고리즘은 4단계로 이루어짐.

문제 정의: 문제가 무엇인지, 입력과 출력의 형태로 정의될 수 있는지, 컴퓨터가 수행할 수 있는 형태로 전환이 가능한지.
알고리즘 설명: 컴퓨터가 수행해야 할 내용을 하나씩 절차순으로 정의한 과정.
정확성 증명: 과정대로 수행할 시 모든 케이스에 바른 답을 내놓는지, 잘못된 답을 내놓는 경우는 없는지, 출력 뒤 정상적으로 종료되는지.
성능 분석: 수행시간과 사용공간.


2. 알고리즘의 분석
특정 기계에서 수행시간을 측정하는 것은 공정하지 않음. (기기, 환경 차이에 따라 수행시간이 달라짐.)
그러나 특정 기계에서 모든 알고리즘의 수행시간을 측정하는 것은 불가능하므로 수행연산의 횟수를 비교한다.

수행시간 분석: 입력으로 크기가 커지면 커질수록 시간이 많이 걸린다.
그에 따라 수행시간은 입력 크기 n에 대한 함수로 표현함.

성능 분석: 세 가지 비교 대상이 존재함.
산술 연산: +, *, mod 등.
데이터 입출력: copy, move, save, load 등.
제어 연산: if, while, register 등.

성능 분석 뒤 그 결과를 명확하게 표기하기 위한 방법이 점근적 표기법임.
√그래프 볼 것.
1. O-notation.
O(g(n))={f(n):n≥n_0인 모든 n에 대해 0≤f(n)≤cg(n)를 만족하는 양수 상수 c와 n_0가 존재.}
이 때 g(n)을 함수 f(n)의 점근적 상한(asymptotic upper bound)라고 함.
2. Ω-notation.
Ω(g(n))={f(n):n≥n_0인 모든 n에 대해 0≤cg(n)≤f(n)를 만족하는 양수 상수 c와 n_0가 존재.}
이 때 g(n)을 함수 f(n)의 점근적 하한(asymptotic lower bound)라고 함.
3. θ-notation.
θ(g(n))={f(n):n≥n_0인 모든 n에 대해 0≤c_1g(n)≤f(n))≤c_2g(n)를 만족하는 양수 상수 c_1, c_2와 n_0가 존재.}
이 때 g(n)을 함수 f(n)의 점근적 상한 및 하한(asymptotically tight bound)라고 함.



3. 정렬문제(Sorting problem)란?
*입력(Input): n개의 숫자들의 배열.
*출력(Output): 입력된 숫자의 배열이 오름차순(혹은 내림차순) 조건을 만족하도록 다시 나열한 결과.

선택정렬(Selection sort)
https://www.slideshare.net/HumanoTerricola/analisys-of-selection-sort-and-bubble-sort (p.3~p.9)
알고리즘 설명: 말 그대로 선택을 통해 정렬하는 알고리즘. 무엇을 선택할지에 따라 두 가지로 나뉨.
1. 최소값 선택 정렬 (Min-selection sort)
가장 작은 값을 선택 (오름차순)
2. 최대값 선택 정렬 (Max-selection sort)
가장 큰 값을 선택 (내림차순)
정확성 증명: 수학적 귀납법을 이용해 증명함.
시간 복잡도는 θ(n^2).

삽입정렬(Insertion sort)
https://www.geeksforgeeks.org/insertion-sort/
알고리즘 설명: Key 값과 정렬된 리스트가 주어졌을 때 key 값을 정렬된 리스트의 알맞은 위치에 삽입하는 알고리즘.
Key를 지정한 뒤 리스트의 주변 값과 비교해 이동해 삽입하는 방식.
수행시간:
최선의 경우는 배열 A[1..n]이 이미 정렬된 상태일 경우로, 해당 배열에 대해 n에 대한 선형함수이므로 an+b로 표현 가능하다.
최악의 경우는 배열 A[1..n]이 원하는 순의 반대로 정렬된 상태이다. 해당 배열에 대해 2차함수이므로 an^2+bn+c로 표현 가능하다.
시간 복잡도는 θ(n^2).
공간 복잡도는 Sorted in place(추가 공간을 사용하지 않는다.)이므로 θ(n).
